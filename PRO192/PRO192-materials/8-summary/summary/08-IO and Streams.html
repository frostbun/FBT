<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=File-List href="08-IO%20and%20Streams_files/filelist.xml">
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Phan</o:Author>
  <o:LastAuthor>Phan</o:LastAuthor>
  <o:Revision>3</o:Revision>
  <o:TotalTime>0</o:TotalTime>
  <o:Created>2016-05-14T07:18:00Z</o:Created>
  <o:LastSaved>2016-05-14T07:18:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>1319</o:Words>
  <o:Characters>7523</o:Characters>
  <o:Company>Microsoft Corporation</o:Company>
  <o:Lines>62</o:Lines>
  <o:Paragraphs>17</o:Paragraphs>
  <o:CharactersWithSpaces>8825</o:CharactersWithSpaces>
  <o:Version>11.6360</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	mso-outline-level:1;
	font-size:24.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
p
	{font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
@page Section1
	{size:612.0pt 792.0pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	mso-header-margin:36.0pt;
	mso-footer-margin:36.0pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]-->
</head>

<body lang=EN-US link=blue vlink=blue style='tab-interval:36.0pt'>

<div class=Section1>

<p><a href="../summary.htm">Return to Summary</a> </p>

<h1>Chapter 8. I/O and Streams</h1>

<p><strong>1. &nbsp;&nbsp;&nbsp; </strong>Which of the statements below are
true?<br>
UTF characters are all 8 bits.<br>
UTF characters are all 16 bits.<br>
UTF characters are all 24 bits.<br>
<strong>Unicode characters are all 16 bits.</strong><br>
Bytecode characters are all 16 bits.<br>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>UTF characters are
as big as they need to be. Unicode characters are all 16 bits. There is no such
thing as a bytecode character; bytecode is the format generated by the Java
compiler.<br>
<strong>2. &nbsp;&nbsp;&nbsp; </strong>The File constructor doesn’t check the
file-naming semantics. If the corresponding file does not exist on the local
file system, it will <strong>not be</strong> <strong>created</strong>.
Construction and garbage collection of a File have no effect on the local file
system, thus if an instance of File is garbage collected, the corresponding
file on the local file system is <strong>not deleted</strong>.<br>
<strong>3. &nbsp;&nbsp;&nbsp; </strong>The File class does not provide a way to
change the current working directory.<br>
<strong>4.&nbsp;&nbsp;&nbsp;&nbsp; </strong>How do you use the File class to
list the contents of a directory?<br>
String[] contents = myFile.list();<br>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>The list() method
returns an array of strings.<br>
<strong>5.&nbsp;&nbsp;&nbsp;&nbsp; </strong>How many bytes does the following
code write to file dest?<br>
1. try {<br>
2.&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;FileOutputStream fos =
newFileOutputStream(“dest”);<br>
3. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream dos = new DataOutputStream(fos);<br>
4. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dos.writeInt(3);<br>
5. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dos.writeDouble(0.0001);<br>
6. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dos.close();<br>
7. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fos.close();<br>
8. &nbsp;&nbsp;}<br>
9. &nbsp;&nbsp;catch (IOException e) { }<br>
12<br>
The writeInt() call writes out an int, which is 4 bytes long; the writeDouble()
call writes out a double, which is 8 bytes long. The total is 12 bytes.<br>
<strong>6.&nbsp;&nbsp;&nbsp;&nbsp; </strong>What does the following code
fragment print out at line 9?<br>
1. FileOutputStream fos = new FileOutputStream(“xx”);<br>
2. for (byte b=10; b&lt;50; b++)<br>
3. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fos.write(b);<br>
4. fos.close();<br>
5. RandomAccessFile raf = new RandomAccessFile(“xx”, “r”);<br>
6. raf.seek(10);<br>
7. int i = raf.read();<br>
8. raf.close()<br>
9. System.out.println(“i = “ + i);<br>
The output is i = 20.<br>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>All the code is
perfectly legal, so no exceptions are thrown. The first byte in the file is 10,
the next byte is 11, the next is 12, and so on. The byte at file position 10 is
20, so the output is i = 20.<br>
<strong>7. &nbsp;&nbsp;&nbsp; </strong>A file is created with the following
code:<br>
1. FileOutputStream fos = new FileOutputStream(“datafile”);<br>
2. DataOutputStream dos = new DataOutputStream(fos);<br>
3. for (int i=0; i&lt;500; i++)<br>
4. dos.writeInt(i);<br>
You would like to write code to read back the data from this file. Which
solutions will work? <br>
<strong>A. </strong>Construct a FileInputStream, passing the name of the file.
Onto the FileInputStream, chain a DataInputStream, and call its readInt()
method.<br>
<strong>B. </strong>Construct a RandomAccessFile, passing the name of the file.
Call the random access file’s readInt() method.<br>
<strong>8. &nbsp;&nbsp;&nbsp; </strong>Which of the following is true?<br>
<strong>A. </strong>Readers have methods that can read and return floats and
doubles.<br>
<strong>B. </strong>Readers have methods that can read and return floats.<br>
<strong>C. </strong>Readers have methods that can read and return doubles.<br>
<strong>D. </strong>Readers have methods that can read and return ints.<br>
<strong>E. None of the above.</strong><br>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>Readers and writers
deal only with character I/O.<br>
<strong>9.&nbsp;&nbsp;&nbsp;&nbsp; </strong>You execute the following code in
an empty directory. What is the result?<br>
1. File f1 = new File(“dirname”);<br>
2. File f2 = new File(f1, “filename”);<br>
No directory is created, and no file is created.<br>
Constructing an instance of the File class has no effect on the local file
system.<br>
<strong>10. </strong>What is the result of attempting to compile and execute
the following code fragment? Assume that the code fragment is part of an
application that has write permission in the current working directory. Also
assume that before execution, the current working directory does not contain a
file called datafile.<br>
1. try {<br>
2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;RandomAccessFile raf = new<br>
3. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RandomAccessFile(“datafile”
,”rw”);<br>
4. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedOutputStream bos = new<br>
5. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedOutputStream(raf);<br>
6. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream dos = new<br>
7. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream(bos);<br>
8. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dos.writeDouble(Math.PI);<br>
9. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dos.close();<br>
10. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bos.close();<br>
11. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raf.close();<br>
12.&nbsp;&nbsp; &nbsp;}<br>
13. &nbsp;&nbsp;&nbsp;catch (IOException e) { }<br>
The code fails to compile.<br>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>Compilation fails
at lines 4 and 5, because there is no constructor for BufferedOutputStream that
takes a RandomAccessFile object as a parameter. You can be sure of this even if
you are not familiar with buffered output streams, because random-access files
are completely incompatible with the stream/reader/writer model.<br>
<strong>11.&nbsp; </strong>Suppose you are writing a class that will provide
custom serialization. The class implements java.io.Serializable (not
java.io.Externalizable). What access mode should the writeObject() method have?<br>
public<br>
protected<br>
default<br>
<strong>private</strong><br>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>Default
serialization is bypassed only if the writeObject() method has private access.<br>
<strong>12. </strong>Suppose you are writing a class that will provide custom
deserialization. The class implements java.io.Serializable (not
java.io.Externalizable). What access mode should the readObject() method have?<br>
public<br>
protected<br>
default<br>
<strong>private</strong><br>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>Default
deserialization is bypassed only if the readObject() method has private access.<br>
<strong>13.&nbsp; </strong>Suppose class A extends Object; class B extends A;
and class C extends B. Of these, only class C implements java.io.Serializable.
Which of the following must be true in order to avoid an exception during
deserialization of an instance of C?<br>
A. A must have a no-args constructor.<br>
<strong>B. B must have a no-args constructor.</strong><br>
C. C must have a no-args constructor.<br>
D. There are no restrictions regarding no-args constructors.<br>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>The lowest-level
non-serializable superclass of the object being deserialized must have a
no-args constructor.<br>
<strong>14.&nbsp; </strong>Suppose class A extends Object; Class B extends A;
and class C extends B. Of these, only class C implements
java.io.Externalizable. Which of the following must be true in order to avoid
an exception during deserialization of an instance of C?<br>
A. A must have a no-args constructor.<br>
B. B must have a no-args constructor.<br>
<strong>C. C must have a no-args constructor.</strong><br>
D. There are no restrictions regarding no-args constructors.<br>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>An externalizable
object must have a no-args constructor.<br>
<strong>15.&nbsp; </strong>Given the following class:<br>
public class MyClass implements java.io.Serializable {<br>
public int iAmPublic;<br>
private int iAmPrivate;<br>
static int iAmStatic;<br>
transient int iAmTransient;<br>
volatile int iAmVolatile;<br>
. . .<br>
}<br>
Assuming the class does not perform custom serialization, which fields are
written when an instance of MyClass is serialized?<br>
<strong>iAmPublic</strong><br>
<strong>iAmPrivate</strong><br>
<strong>iAmVolatile</strong><br>
iAmStatic<br>
iAmTransient<br>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>Default
serialization writes all non-static non-transient fields.<br>
<strong>16. </strong>What method of the java.io.File class can create a file on
the hard drive?<br>
The createNewFile() method creates a new empty file.<br>
<strong>17. </strong>Both System.out and System.err are instances of
PrintStream, which has a println() method and (as of version 5.0) a format()
method.<br>
<strong>18.&nbsp; </strong>What happens when you try to compile and run the
following application?<br>
1. import java.io.*;<br>
2.<br>
3. public class Xxx {<br>
4. public static void main(String[] args) {<br>
5. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br>
6.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File
f = new File(&quot;xxx.ser&quot;);<br>
7.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileOutputStream
fos = new FileOutputStream(f);<br>
8.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutputStream
oos = new ObjectOutputStream(fos);<br>
9.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oos.writeObject(new
Object());<br>
10.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oos.close();<br>
11.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fos.close();<br>
12. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
13. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception x) { }<br>
14. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
15. &nbsp;&nbsp;}<br>
An exception is thrown at line 9.<br>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>The writeObject()
method is declared to take an Object argument. At runtime, there is a
precondition check to make sure the <em><b>argument implements Serializable</b></em>,
which Object doesn’t do.<br>
<strong>19. </strong>The followings are valid mode strings for the
RandomAccessFile constructor:<br>
“r”, <strong>&nbsp;</strong>“rw”,<strong> </strong>“rws”,<strong> </strong>“rwd”<br>
“r” opens for reading only. “rw” opens for reading and writing. “rws” opens for
reading and writing, with immediate updating of data and metadata changes.
“rwd” opens for reading and writing, with immediate updating of data (but not
metadata) changes.<br>
<strong>20.&nbsp; </strong>Which of the following are valid arguments to the
DataInputStream constructor?<br>
<strong>A. </strong>File<br>
<strong>B. </strong>FileReader<br>
<strong>C. FileInputStream</strong><br>
<strong>D. </strong>RandomAccessFile<br>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>DataInputStream
reads bytes from its data source, which must be an InputStream. The only valid
option is C, FileInputStream.<br>
<strong>21.&nbsp; </strong>What keyword is used to prevent an object from being
serialized?<br>
transient<br>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>By placing the
keyword transient before an object’s declaration, that value will not be
included with the serialized data of the parent object. See Chapter 9 for more
information.<br>
<strong>22. </strong>Suppose you are writing a class that provides custom
deserialization. The class implements java.io.Serializable (and not
java.io.Externalizable). What method should implement the custom
deserialization, and what is its access mode?<br>
private readObject<br>
<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</strong>The readObject() method must be private.</p>

<p>&nbsp;</p>

</div>

</body>

</html>
